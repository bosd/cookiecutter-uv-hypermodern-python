name: Release Template

on:
  # This workflow triggers on push to main/master.
  # It then detects if a new tag (release) should be created.
  # This is the "push-based" release model.
  # If you prefer to trigger *only* on a manual GitHub Release publish,
  # change this to:
  # release:
  #   types: [published]
  # And remove the 'Detect and tag new version' and 'Bump version' steps.
  # However, for automatic tagging and conditional publishing like the example,
  # 'push' is needed here.
  push:
    branches:
      - main
      - master

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write # Required for PyPI Trusted Publishing

    steps:
      - name: Check out the repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python 3.13
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Create uv virtual environment for build
        run: uv venv

      - name: Install build dependencies and toml for version detection
        run: |
          uv pip install toml # Install the 'toml' library
          uv pip install build wheel # Ensure build tools are available via uv

      - name: Set virtual environment python path as job env variable
        run: |
          VENV_PYTHON_PATH="${{ github.workspace }}/.venv/bin/python"

          echo "DEBUG: Setting PYTHON_BIN_FOR_VENV to: ${VENV_PYTHON_PATH}"

          if [ -z "$VENV_PYTHON_PATH" ]; then
            echo "ERROR: VENV_PYTHON_PATH is empty. Virtual environment Python not found!"
            exit 1
          fi

          if [ ! -f "$VENV_PYTHON_PATH" ]; then
            echo "ERROR: Python executable does not exist at computed path: ${VENV_PYTHON_PATH}"
            echo "Please check the .venv/bin/ directory structure."
            ls -la ${{ github.workspace }}/.venv/bin/
            exit 1
          fi

          echo "PYTHON_BIN_FOR_VENV=${VENV_PYTHON_PATH}" >> "$GITHUB_ENV"
          echo "DEBUG: Successfully set job environment variable PYTHON_BIN_FOR_VENV to: ${VENV_PYTHON_PATH}"

      - name: Debug Python Path Output (Verify Job Env Variable)
        run: |
          echo "Debug: PYTHON_BIN_FOR_VENV as seen in this step is '${{ env.PYTHON_BIN_FOR_VENV }}'"
          if [ -z "${{ env.PYTHON_BIN_FOR_VENV }}" ]; then
            echo "CRITICAL ERROR: PYTHON_BIN_FOR_VENV is STILL empty when accessed from a subsequent step. This is a GitHub Actions env var bug."
            exit 1
          fi
          if [ ! -f "${{ env.PYTHON_BIN_FOR_VENV }}" ]; then
            echo "CRITICAL ERROR: Python executable not found at propagated env var path: '${{ env.PYTHON_BIN_FOR_VENV }}'"
            exit 1
          fi

      - name: Check if there is a parent commit
        id: check-parent-commit
        run: |
          echo "sha=$(git rev-parse --verify --quiet HEAD^)" >> "$GITHUB_OUTPUT"

      - name: Detect and tag new version
        id: check-version
        if: steps.check-parent-commit.outputs.sha
        uses: salsify/action-detect-and-tag-new-version@v2.0.3
        with:
          version-command: echo "${{ steps.get_version.outputs.PROJECT_VERSION }}"

      - name: Bump version for developmental release
        if: "! steps.check-version.outputs.tag"
        run: |
          PYTHON_EXE="${{ env.PYTHON_BIN_FOR_VENV }}"
          if [ -z "$PYTHON_EXE" ]; then
            echo "ERROR: PYTHON_EXE is empty in 'bump version' step. Cannot proceed."
            exit 1
          fi

          PYPROJECT_TOML_PATH="${{ github.workspace }}/pyproject.toml"
          echo "DEBUG (Bump): Current working directory: $(pwd)"
          echo "DEBUG (Bump): Expected pyproject.toml path: ${PYPROJECT_TOML_PATH}"
          if [ -f "${PYPROJECT_TOML_PATH}" ]; then
            echo "DEBUG (Bump): pyproject.toml FOUND at ${PYPROJECT_TOML_PATH}."
            ls -l "${PYPROJECT_TOML_PATH}"
          else
            echo "CRITICAL ERROR (Bump): pyproject.toml NOT FOUND at ${PYPROJECT_TOML_PATH}."
            echo "Listing contents of repository root:"
            ls -la "${{ github.workspace }}"
            echo "Listing contents of current working directory:"
            ls -la "$(pwd)"
            exit 1
          fi

          CURRENT_VERSION=$("${PYTHON_EXE}" -c "import toml; print(toml.load('${{ github.workspace }}/pyproject.toml')['project']['version'])")
          DEVELOPMENT_VERSION="${CURRENT_VERSION}.dev.$(date +%s)"
          echo "Bumping version to ${DEVELOPMENT_VERSION} for TestPyPI release."

      - name: Build package with uv
        run: uv build

      - name: Publish package on PyPI
        # This step runs ONLY if a new tag (official release) was created by the previous step.
        if: steps.check-version.outputs.tag
        uses: pypa/gh-action-pypi-publish@release/v1 # Using the latest recommended stable release
        with:
          # Recommended: Use PyPI Trusted Publishing.
          # Configure your PyPI project to trust this GitHub repo.
          # If set up, 'username' and 'password' are not needed here.
          # Otherwise, use your PyPI API token:
          user: __token__
          password: ${{ secrets.PYPI_API_TOKEN }}

      - name: Publish package on TestPyPI
        # This step runs if NO new tag was created (i.e., a regular push to main/master).
        if: "! steps.check-version.outputs.tag"
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          # Use your TestPyPI API token:
          user: __token__
          password: ${{ secrets.TEST_PYPI_TOKEN }} # Ensure this secret is configured
          repository-url: https://test.pypi.org/legacy/

      # Note: The `Publish the release notes` step from your example is handled by
      # your separate `release-drafter.yml` workflow, which is good.
      # That workflow handles the GitHub Release creation, this one handles PyPI publishing.
